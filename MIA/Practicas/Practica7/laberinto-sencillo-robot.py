# -*- coding: utf-8 -*-
"""red-neuronal-1-coche.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1AEUa2uEmKoVur-zfvTjyjw0rNWcrjOwO
"""

import numpy as np
import random
import matplotlib.pyplot as plt
from sklearn.neural_network import MLPClassifier

# --- Entrenamiento del modelo de IA con una tabla de decisiones ajustada ---
import numpy as np
import random
import matplotlib.pyplot as plt
from sklearn.neural_network import MLPClassifier

def entrenar_modelo_nuevo_sklearn():
    # Conjunto de datos expandido para cubrir más escenarios de navegación
    inputs = np.array([
        # Escenarios básicos de obstáculos
        [0, 0, 0],  # No hay obstáculos - libre de avanzar
        [0, 0, 1],  # Obstáculo a la derecha - aún se puede avanzar
        [0, 1, 0],  # Obstáculo a la izquierda - aún se puede avanzar
        [1, 0, 0],  # Obstáculo al frente - necesita girar
        
        # Escenarios con múltiples obstáculos
        [1, 1, 0],  # Obstáculo al frente y a la izquierda - girar a la derecha
        [1, 0, 1],  # Obstáculo al frente y a la derecha - situación compleja
        [0, 1, 1],  # Obstáculos en los lados izquierdo y derecho - aún puede avanzar
        [1, 1, 1]   # Completamente bloqueado - necesita estrategia de escape
    ])

    # Salidas correspondientes a los escenarios de entrada
    outputs = np.array([
        [0, 0, 1],  # Avanzar - sin obstáculos
        [0, 0, 1],  # Avanzar - obstáculo derecho no bloquea
        [0, 0, 1],  # Avanzar - obstáculo izquierdo no bloquea
        [1, 0, 0],  # Girar a la derecha - obstáculo al frente
        
        [1, 0, 0],  # Girar a la derecha - obstáculos frente e izquierda
        [0, 1, 0],  # Girar a la izquierda - obstáculos complejos
        [0, 0, 1],  # Avanzar - obstáculos laterales no bloquean
        [0, 1, 0]   # Girar a la izquierda - completamente bloqueado
    ])

    model = MLPClassifier(hidden_layer_sizes=(16, 12), activation='relu', max_iter=500, random_state=42)
    model.fit(inputs, np.argmax(outputs, axis=1))  # Usar el índice de la acción como salida
    return model

# --- Crear el laberinto con un camino ---
def crear_laberinto_con_camino(tamaño=10):
    laberinto = np.ones((tamaño, tamaño))  # Comienza con un laberinto lleno de paredes
    camino = [(0, 0)]
    laberinto[0, 0] = 0  # Punto inicial libre
    x, y = 0, 0
    while (x, y) != (tamaño - 1, tamaño - 1):
        if random.random() < 0.5 and y < tamaño - 1:
            y += 1
        elif x < tamaño - 1:
            x += 1
        laberinto[x, y] = 0
        camino.append((x, y))
    for i in range(tamaño):
        for j in range(tamaño):
            if (i, j) not in camino and random.random() < 0.3:
                laberinto[i][j] = 1
    return laberinto

# --- Mostrar el laberinto ---
def mostrar_laberinto_con_orientacion(laberinto, posicion_robot, direccion_robot, posicion_salida):
    plt.imshow(laberinto, cmap='gray')
    plt.scatter(posicion_salida[1], posicion_salida[0], color='green', label='Salida', marker='X', s=200)
    orientaciones = {
        "N": "^",  # Norte
        "E": ">",  # Este
        "S": "v",  # Sur
        "W": "<"   # Oeste
    }
    plt.text(posicion_robot[1], posicion_robot[0], orientaciones[direccion_robot], fontsize=12, ha='center', va='center', color='red')
    plt.legend()
    plt.title("Laberinto con Orientación del Robot")
    plt.show()

# --- Obtener sensores ajustados para detectar los bordes como obstáculos ---
def obtener_sensores(laberinto, posicion, direccion):
    tamaño = laberinto.shape[0]
    sensores = [0, 0, 0]
    movimientos = {
        "N": [(-1, 0), (0, -1), (0, 1)],
        "S": [(1, 0), (0, 1), (0, -1)],
        "E": [(0, 1), (-1, 0), (1, 0)],
        "W": [(0, -1), (1, 0), (-1, 0)]
    }
    for idx, (di, dj) in enumerate(movimientos[direccion]):
        ni, nj = posicion[0] + di, posicion[1] + dj
        # Verificar si el nuevo índice está fuera de los límites del laberinto
        if not (0 <= ni < tamaño and 0 <= nj < tamaño) or laberinto[ni][nj] == 1:
            sensores[idx] = 1
    return sensores

# --- Mover el robot ---
def mover_robot(posicion, direccion, accion, laberinto):
    movimientos = {"N": (-1, 0), "S": (1, 0), "E": (0, 1), "W": (0, -1)}
    direcciones = ["N", "E", "S", "W"]
    if accion == "avanzar":
        nueva_posicion = (posicion[0] + movimientos[direccion][0], posicion[1] + movimientos[direccion][1])
    elif accion == "girar_derecha":
        nueva_direccion = direcciones[(direcciones.index(direccion) + 1) % 4]
        return posicion, nueva_direccion
    elif accion == "girar_izquierda":
        nueva_direccion = direcciones[(direcciones.index(direccion) - 1) % 4]
        return posicion, nueva_direccion
    else:
        nueva_posicion = posicion
    if 0 <= nueva_posicion[0] < laberinto.shape[0] and 0 <= nueva_posicion[1] < laberinto.shape[1] and laberinto[nueva_posicion] == 0:
        return nueva_posicion, direccion
    return posicion, direccion

# --- Simulación del laberinto ---
def simular_laberinto_con_detalle_texto():
    tamaño = 10
    laberinto = crear_laberinto_con_camino(tamaño)
    posicion = (0, 0)
    direccion = "E"  # Inicia hacia el Este
    objetivo = (tamaño - 1, tamaño - 1)
    pasos = 0
    max_pasos = 100
    model = entrenar_modelo_nuevo_sklearn()

    while posicion != objetivo and pasos < max_pasos:
        sensores = obtener_sensores(laberinto, posicion, direccion)
        accion_idx = model.predict([sensores])[0]
        accion = ["girar_derecha", "girar_izquierda", "avanzar"][accion_idx]

        # Mostrar los valores de los sensores y la decisión de la red neuronal
        print(f"Paso {pasos}:")
        print(f"  Posición: {posicion}, Dirección: {direccion}")
        print(f"  Sensores (Frontal, Izquierdo, Derecho): {sensores}")
        print(f"  Acción predicha por la red neuronal: {accion}")
        print(f"  Índice de acción predicho: {accion_idx}\\n")

        nueva_posicion, nueva_direccion = mover_robot(posicion, direccion, accion, laberinto)

        # Actualizar posición y dirección del robot según la acción predicha
        posicion, direccion = nueva_posicion, nueva_direccion

        pasos += 1
        # Mostrar el laberinto con orientación después de mostrar la información de texto
        mostrar_laberinto_con_orientacion(laberinto, posicion, direccion, objetivo)

    return "El robot ha salido del laberinto" if posicion == objetivo else "El robot no logró salir"

resultado_simulacion_texto = simular_laberinto_con_detalle_texto()
print(resultado_simulacion_texto)