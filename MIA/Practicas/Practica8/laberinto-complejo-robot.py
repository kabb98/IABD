# -*- coding: utf-8 -*-
"""red-neuronal-2-coche.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1AEUa2uEmKoVur-zfvTjyjw0rNWcrjOwO
"""

import numpy as np
import random
import matplotlib.pyplot as plt
from sklearn.neural_network import MLPClassifier

# --- Entrenamiento del modelo de IA con una tabla de decisiones ajustada ---
def entrenar_modelo_nuevo_sklearn():
    # Conjunto de datos ajustado para reflejar que siempre avanzamos si no hay obstáculo al frente
    inputs = np.array([
        [0, 0, 0],  # No hay obstáculos
        [0, 0, 1],  # Obstáculo a la derecha
        [0, 1, 0],  # Obstáculo a la izquierda
    ])

    # Salidas ajustadas para reflejar la lógica de avanzar si el frente está libre
    outputs = np.array([
        [0, 0, 1],  # Avanzar si no hay obstáculos
        [0, 0, 1],  # Avanzar si solo hay obstáculo a la derecha
        [0, 0, 1],  # Avanzar si solo hay obstáculo a la izquierda
    ])

    model = MLPClassifier(hidden_layer_sizes=(16, 12), activation='relu', max_iter=1, random_state=42)
    model.fit(inputs, np.argmax(outputs, axis=1))  # Usar el índice de la acción como salida
    return model

# --- Crear el laberinto con un camino ---
def crear_laberinto_con_camino(tamaño=10):
    laberinto = np.ones((tamaño, tamaño))  # Comienza con un laberinto lleno de paredes
    camino = [(0, 0)]
    laberinto[0, 0] = 0  # Punto inicial libre
    x, y = 0, 0

    # Generar un camino garantizado al destino usando movimientos aleatorios
    while (x, y) != (tamaño - 1, tamaño - 1):
        if random.random() < 0.5 and y < tamaño - 1:
            y += 1
        elif x < tamaño - 1:
            x += 1
        laberinto[x, y] = 0
        camino.append((x, y))

    # Mejorar la complejidad del laberinto agregando más caminos y paredes adicionales
    for _ in range(int(tamaño * tamaño * 0.3)):  # Controla cuántas celdas intentar abrir
        cx, cy = random.randint(0, tamaño - 1), random.randint(0, tamaño - 1)
        if laberinto[cx, cy] == 1:  # Solo abrir si es una pared
            # Asegurarse de que no se rompa la conectividad del camino principal
            laberinto[cx, cy] = 0
            if not hay_camino_garantizado(laberinto, (0, 0), (tamaño - 1, tamaño - 1)):
                laberinto[cx, cy] = 1  # Restaurar si no hay camino

    return laberinto

def hay_camino_garantizado(laberinto, inicio, fin):
    tamaño = laberinto.shape[0]
    visitado = [[False for _ in range(tamaño)] for _ in range(tamaño)]

    def dfs(x, y):
        if not (0 <= x < tamaño and 0 <= y < tamaño) or laberinto[x, y] == 1 or visitado[x][y]:
            return False
        if (x, y) == fin:
            return True
        visitado[x][y] = True
        # Intentar moverse en las cuatro direcciones
        return (dfs(x + 1, y) or dfs(x - 1, y) or dfs(x, y + 1) or dfs(x, y - 1))

    return dfs(inicio[0], inicio[1])

# --- Mostrar el laberinto ---
def mostrar_laberinto_con_orientacion(laberinto, posicion_robot, direccion_robot, posicion_salida):
    plt.imshow(laberinto, cmap='gray')
    plt.scatter(posicion_salida[1], posicion_salida[0], color='green', label='Salida', marker='X', s=200)
    orientaciones = {
        "N": "^",  # Norte
        "E": ">",  # Este
        "S": "v",  # Sur
        "W": "<"   # Oeste
    }
    plt.text(posicion_robot[1], posicion_robot[0], orientaciones[direccion_robot], fontsize=12, ha='center', va='center', color='red')
    plt.legend()
    plt.title("Laberinto con Orientación del Robot")
    plt.show()

# --- Obtener sensores ajustados para detectar los bordes como obstáculos ---
def obtener_sensores(laberinto, posicion, direccion):
    tamaño = laberinto.shape[0]
    sensores = [0, 0, 0]
    movimientos = {
        "N": [(-1, 0), (0, -1), (0, 1)],
        "S": [(1, 0), (0, 1), (0, -1)],
        "E": [(0, 1), (-1, 0), (1, 0)],
        "W": [(0, -1), (1, 0), (-1, 0)]
    }
    for idx, (di, dj) in enumerate(movimientos[direccion]):
        ni, nj = posicion[0] + di, posicion[1] + dj
        # Verificar si el nuevo índice está fuera de los límites del laberinto
        if not (0 <= ni < tamaño and 0 <= nj < tamaño) or laberinto[ni][nj] == 1:
            sensores[idx] = 1
    return sensores

# --- Mover el robot ---
def mover_robot(posicion, direccion, accion, laberinto):
    movimientos = {"N": (-1, 0), "S": (1, 0), "E": (0, 1), "W": (0, -1)}
    direcciones = ["N", "E", "S", "W"]
    if accion == "avanzar":
        nueva_posicion = (posicion[0] + movimientos[direccion][0], posicion[1] + movimientos[direccion][1])
    elif accion == "girar_derecha":
        nueva_direccion = direcciones[(direcciones.index(direccion) + 1) % 4]
        return posicion, nueva_direccion
    elif accion == "girar_izquierda":
        nueva_direccion = direcciones[(direcciones.index(direccion) - 1) % 4]
        return posicion, nueva_direccion
    else:
        nueva_posicion = posicion
    if 0 <= nueva_posicion[0] < laberinto.shape[0] and 0 <= nueva_posicion[1] < laberinto.shape[1] and laberinto[nueva_posicion] == 0:
        return nueva_posicion, direccion
    return posicion, direccion

# --- Simulación del laberinto ---
def simular_laberinto_con_detalle_texto():
    tamaño = 10
    laberinto = crear_laberinto_con_camino(tamaño)
    posicion = (0, 0)
    direccion = "E"  # Inicia hacia el Este
    objetivo = (tamaño - 1, tamaño - 1)
    pasos = 0
    max_pasos = 100
    model = entrenar_modelo_nuevo_sklearn()

    while posicion != objetivo and pasos < max_pasos:
        sensores = obtener_sensores(laberinto, posicion, direccion)
        accion_idx = model.predict([sensores])[0]
        accion = ["girar_derecha", "girar_izquierda", "avanzar"][accion_idx]

        # Mostrar los valores de los sensores y la decisión de la red neuronal
        print(f"Paso {pasos}:")
        print(f"  Posición: {posicion}, Dirección: {direccion}")
        print(f"  Sensores (Frontal, Izquierdo, Derecho): {sensores}")
        print(f"  Acción predicha por la red neuronal: {accion}")
        print(f"  Índice de acción predicho: {accion_idx}\\n")

        nueva_posicion, nueva_direccion = mover_robot(posicion, direccion, accion, laberinto)

        # Actualizar posición y dirección del robot según la acción predicha
        posicion, direccion = nueva_posicion, nueva_direccion

        pasos += 1
        # Mostrar el laberinto con orientación después de mostrar la información de texto
        mostrar_laberinto_con_orientacion(laberinto, posicion, direccion, objetivo)

    return "El robot ha salido del laberinto" if posicion == objetivo else "El robot no logró salir"

resultado_simulacion_texto = simular_laberinto_con_detalle_texto()
print(resultado_simulacion_texto)